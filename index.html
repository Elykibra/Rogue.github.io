<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dungeon Party</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        
        body {
            font-family: 'Press Start 2P', cursive;
            background-color: #1a1a1a;
            color: #e5e5e5;
            touch-action: none; /* Prevent scroll on mobile tap */
        }

        .pixel-border {
            box-shadow: 
                -4px 0 0 0 #e5e5e5,
                4px 0 0 0 #e5e5e5,
                0 -4px 0 0 #e5e5e5,
                0 4px 0 0 #e5e5e5;
            margin: 4px;
        }

        .btn-pixel {
            position: relative;
            display: inline-block;
            padding: 15px 30px;
            background: #4a4a4a;
            color: white;
            text-transform: uppercase;
            border: none;
            cursor: pointer;
            box-shadow: inset -4px -4px 0px 0px rgba(0,0,0,0.5), inset 4px 4px 0px 0px rgba(255,255,255,0.2);
        }
        
        .btn-pixel:active {
            transform: translateY(2px);
            box-shadow: inset -2px -2px 0px 0px rgba(0,0,0,0.5), inset 2px 2px 0px 0px rgba(255,255,255,0.2);
        }

        .btn-pixel.primary { background: #3b82f6; }
        .btn-pixel.secondary { background: #10b981; }
        .btn-pixel.danger { background: #ef4444; }

        canvas {
            image-rendering: pixelated; /* Sharp pixels */
            width: 100%;
            height: 100%;
        }

        #dpad button {
            width: 60px;
            height: 60px;
            background: rgba(255,255,255,0.1);
            border: 2px solid #555;
            border-radius: 8px;
            color: white;
            font-size: 20px;
        }
        #dpad button:active { background: rgba(255,255,255,0.3); }
    </style>
</head>
<body class="h-screen w-screen overflow-hidden flex flex-col items-center justify-center p-4">

    <div id="app" class="relative z-20 w-full max-w-2xl h-full flex flex-col justify-center">
        
        <!-- HEADER -->
        <div id="header" class="text-center mb-4 shrink-0">
            <h1 class="text-xl md:text-2xl text-yellow-400 mb-2 text-shadow">DUNGEON SYNC</h1>
        </div>

        <!-- ERROR MESSAGE -->
        <div id="error-display" class="hidden mb-4 p-2 bg-red-900/90 border-2 border-red-500 text-red-200 text-xs text-center fixed top-4 left-4 right-4 z-50"></div>

        <!-- VIEW: LOADING -->
        <div id="view-loading" class="text-center">
            <p class="animate-pulse text-blue-300">Connecting to Nethernet...</p>
        </div>

        <!-- VIEW: MAIN MENU -->
        <div id="view-menu" class="hidden flex flex-col gap-6 items-center">
            <div class="pixel-border p-8 bg-gray-800 text-center w-full max-w-md">
                <p id="user-display" class="text-xs text-blue-300 mb-8 truncate"></p>
                <div class="flex flex-col gap-4">
                    <button id="btn-create-menu" class="btn-pixel primary">Create Party</button>
                    <button id="btn-join-menu" class="btn-pixel secondary">Join Party</button>
                </div>
            </div>
        </div>

        <!-- VIEW: JOIN INPUT -->
        <div id="view-join-input" class="hidden w-full flex justify-center">
            <div class="pixel-border p-6 bg-gray-800 w-full max-w-md">
                <h2 class="text-center mb-6 text-yellow-400">Enter Room Code</h2>
                <input type="text" id="input-room-code" maxlength="4" placeholder="ABCD" 
                    class="w-full bg-gray-900 border-2 border-gray-600 p-4 text-center text-xl tracking-[0.5em] text-white uppercase mb-6 focus:outline-none focus:border-blue-500">
                <div class="flex gap-4">
                    <button id="btn-back-join" class="btn-pixel w-1/2">Back</button>
                    <button id="btn-confirm-join" class="btn-pixel secondary w-1/2">Connect</button>
                </div>
            </div>
        </div>

        <!-- VIEW: LOBBY -->
        <div id="view-lobby" class="hidden w-full flex justify-center">
            <div class="pixel-border p-6 bg-gray-800 w-full max-w-md">
                <div class="flex justify-between items-center mb-6 border-b-2 border-gray-600 pb-4">
                    <div>
                        <span class="text-xs text-gray-400 block mb-1">ROOM CODE</span>
                        <span id="display-room-code" class="text-2xl text-yellow-400 tracking-widest cursor-pointer">????</span>
                    </div>
                    <div id="lobby-status" class="text-xs bg-green-900 text-green-300 px-2 py-1">WAITING</div>
                </div>

                <div class="mb-6">
                    <h3 class="text-xs text-blue-300 mb-4">PARTY MEMBERS</h3>
                    <div id="player-list" class="space-y-3"></div>
                </div>

                <div id="host-controls" class="hidden border-t-2 border-gray-600 pt-4 mt-4">
                    <button id="btn-start-game" class="btn-pixel secondary w-full mb-2">Enter Dungeon</button>
                </div>

                <div id="guest-controls" class="hidden border-t-2 border-gray-600 pt-4 mt-4">
                    <p class="text-xs text-center animate-pulse">Waiting for host...</p>
                </div>
                <button id="btn-leave-lobby" class="btn-pixel danger w-full mt-4 text-xs">Leave</button>
            </div>
        </div>

        <!-- VIEW: GAME -->
        <div id="view-game" class="hidden flex-col h-full items-center">
            <div class="relative w-full max-w-md aspect-square bg-black pixel-border mb-2 overflow-hidden">
                <canvas id="game-canvas" width="400" height="400"></canvas>
                <!-- Loading overlay for guests waiting for map -->
                <div id="game-loading" class="absolute inset-0 bg-black/80 flex items-center justify-center hidden">
                    <span class="text-yellow-400 animate-pulse">Syncing Map...</span>
                </div>
            </div>
            
            <div class="flex justify-between w-full max-w-md px-2 items-center">
                <p class="text-[10px] text-gray-400">Arrows/WASD to move</p>
                <button id="btn-exit-game" class="text-[10px] text-red-400 hover:text-red-200 uppercase">Exit Run</button>
            </div>

            <!-- Mobile Controls -->
            <div id="dpad" class="mt-4 grid grid-cols-3 gap-2 md:hidden">
                <div></div>
                <button id="btn-up">▲</button>
                <div></div>
                <button id="btn-left">◀</button>
                <button id="btn-down">▼</button>
                <button id="btn-right">▶</button>
            </div>
        </div>

    </div>

    <!-- FIREBASE MODULES -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, getDoc, updateDoc, onSnapshot, arrayUnion, collection } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- CONFIGURATION ---
        const firebaseConfig = JSON.parse(__firebase_config);
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

        // --- STATE ---
        let currentUser = null;
        let currentRoomId = null;
        let roomUnsubscribe = null;
        let gameLoopId = null;
        
        // Game State
        let localGrid = []; // 2D array [y][x]
        let playersMap = {}; // { uid: { x, y, color, name } }
        const TILE_SIZE = 20; // Size for logic (not pixels)
        const GRID_W = 15;
        const GRID_H = 15;
        
        const COLORS = ['#3b82f6', '#10b981', '#f59e0b', '#ec4899', '#8b5cf6'];
        const NAMES = ["Rogue", "Knight", "Wizard", "Cleric", "Bard"];

        // --- DOM ---
        const views = {
            loading: document.getElementById('view-loading'),
            menu: document.getElementById('view-menu'),
            join: document.getElementById('view-join-input'),
            lobby: document.getElementById('view-lobby'),
            game: document.getElementById('view-game')
        };
        const els = {
            error: document.getElementById('error-display'),
            canvas: document.getElementById('game-canvas'),
            gameLoading: document.getElementById('game-loading')
        };
        const ctx = els.canvas.getContext('2d');

        // --- AUTH ---
        const initAuth = async () => {
            try {
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                    await signInAnonymously(auth);
                }
            } catch (e) { showError(e.message); }
        };

        onAuthStateChanged(auth, (user) => {
            if (user) {
                currentUser = user;
                // Assign a color and name deterministicly based on UID char code
                const colorIdx = user.uid.charCodeAt(0) % COLORS.length;
                const nameIdx = user.uid.charCodeAt(0) % NAMES.length;
                currentUser.gameColor = COLORS[colorIdx];
                currentUser.gameName = NAMES[nameIdx];
                
                document.getElementById('user-display').textContent = `ID: ${currentUser.gameName} ${user.uid.substr(0,4)}`;
                switchView('menu');
            }
        });

        // --- LOBBY LOGIC ---
        function switchView(name) {
            Object.values(views).forEach(el => el.classList.add('hidden'));
            views[name].classList.remove('hidden');
            els.error.classList.add('hidden');
            
            // Resize canvas if game
            if (name === 'game') {
                resizeCanvas();
            }
        }

        function showError(msg) {
            els.error.textContent = msg;
            els.error.classList.remove('hidden');
            setTimeout(() => els.error.classList.add('hidden'), 3000);
        }

        async function createRoom() {
            const chars = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789";
            let code = "";
            for(let i=0; i<4; i++) code += chars.charAt(Math.floor(Math.random() * chars.length));

            const roomRef = doc(db, 'artifacts', appId, 'public', 'data', 'lobbies', code);
            await setDoc(roomRef, {
                hostId: currentUser.uid,
                status: 'waiting',
                players: [{ uid: currentUser.uid, name: currentUser.gameName, color: currentUser.gameColor }]
            });
            currentRoomId = code;
            subscribeToRoom(code);
        }

        async function joinRoom(code) {
            code = code.toUpperCase();
            const roomRef = doc(db, 'artifacts', appId, 'public', 'data', 'lobbies', code);
            const snap = await getDoc(roomRef);
            if (!snap.exists()) return showError("Room not found");
            
            const data = snap.data();
            if (!data.players.some(p => p.uid === currentUser.uid)) {
                if (data.status !== 'waiting') return showError("Game in progress");
                await updateDoc(roomRef, {
                    players: arrayUnion({ uid: currentUser.uid, name: currentUser.gameName, color: currentUser.gameColor })
                });
            }
            currentRoomId = code;
            subscribeToRoom(code);
        }

        function subscribeToRoom(code) {
            const roomRef = doc(db, 'artifacts', appId, 'public', 'data', 'lobbies', code);
            roomUnsubscribe = onSnapshot(roomRef, (doc) => {
                if (!doc.exists()) { leaveRoom(); return; }
                const data = doc.data();
                
                // Lobby UI Update
                document.getElementById('display-room-code').textContent = code;
                const list = document.getElementById('player-list');
                list.innerHTML = '';
                data.players.forEach(p => {
                    const el = document.createElement('div');
                    el.className = "flex items-center gap-2 p-2 bg-gray-900 border border-gray-700";
                    el.innerHTML = `<div class="w-4 h-4" style="background:${p.color}"></div><span>${p.name}</span>`;
                    list.appendChild(el);
                });

                // Host/Guest controls
                if (data.hostId === currentUser.uid) {
                    document.getElementById('host-controls').classList.remove('hidden');
                    document.getElementById('guest-controls').classList.add('hidden');
                } else {
                    document.getElementById('host-controls').classList.add('hidden');
                    document.getElementById('guest-controls').classList.remove('hidden');
                }

                // Game Start Transition
                if (data.status === 'playing') {
                    if (data.map) {
                        localGrid = JSON.parse(data.map);
                        playersMap = data.playerStates || {};
                        
                        // First time entering game?
                        if (views.game.classList.contains('hidden')) {
                            enterGameMode();
                        }
                    } else {
                        // Status is playing but map not ready yet (rare race condition)
                        views.game.classList.contains('hidden') ? switchView('game') : null;
                        els.gameLoading.classList.remove('hidden');
                    }
                }
            });
            switchView('lobby');
        }

        async function triggerStart() {
            // HOST LOGIC: Generate Map
            let map = [];
            for(let y=0; y<GRID_H; y++) {
                let row = [];
                for(let x=0; x<GRID_W; x++) {
                    // Simple logic: Border walls, random pillars
                    if (y===0 || y===GRID_H-1 || x===0 || x===GRID_W-1) row.push(1);
                    else if (Math.random() < 0.1) row.push(1);
                    else row.push(0);
                }
                map.push(row);
            }

            // Initial Player States
            const roomRef = doc(db, 'artifacts', appId, 'public', 'data', 'lobbies', currentRoomId);
            const snap = await getDoc(roomRef);
            const players = snap.data().players;
            
            let initialStates = {};
            players.forEach((p, index) => {
                // Spawn players in a line at top left
                initialStates[p.uid] = {
                    x: 2 + index,
                    y: 2,
                    color: p.color,
                    name: p.name
                };
            });

            await updateDoc(roomRef, {
                status: 'playing',
                map: JSON.stringify(map),
                playerStates: initialStates
            });
        }

        function enterGameMode() {
            switchView('game');
            els.gameLoading.classList.add('hidden');
            resizeCanvas();
            // Start render loop
            if (!gameLoopId) loop();
        }

        // --- GAMEPLAY LOGIC ---

        function resizeCanvas() {
            // Make internal resolution match the grid size times a pixel factor
            // We want big chunky pixels.
            const scale = 20; // Each tile is 20x20 pixels on the canvas
            els.canvas.width = GRID_W * scale;
            els.canvas.height = GRID_H * scale;
        }

        async function movePlayer(dx, dy) {
            if (!currentRoomId || !localGrid.length) return;
            
            const myState = playersMap[currentUser.uid];
            if (!myState) return;

            const targetX = myState.x + dx;
            const targetY = myState.y + dy;

            // Collision Check (Walls)
            if (localGrid[targetY] && localGrid[targetY][targetX] === 1) return; // Hit wall

            // Optimistic Update (Move locally immediately)
            myState.x = targetX;
            myState.y = targetY;
            
            // Sync to Firestore
            const roomRef = doc(db, 'artifacts', appId, 'public', 'data', 'lobbies', currentRoomId);
            // Use dot notation to update just this player's position
            const updateField = `playerStates.${currentUser.uid}`;
            
            try {
                await updateDoc(roomRef, {
                    [updateField]: myState
                });
            } catch (e) {
                console.error("Move sync failed", e);
                // Revert on failure would go here
            }
        }

        // --- RENDER LOOP ---
        function draw() {
            // Fill Background
            ctx.fillStyle = '#111';
            ctx.fillRect(0, 0, els.canvas.width, els.canvas.height);

            if (!localGrid.length) return;

            const tileW = els.canvas.width / GRID_W;
            const tileH = els.canvas.height / GRID_H;

            // Draw Map
            for(let y=0; y<GRID_H; y++) {
                for(let x=0; x<GRID_W; x++) {
                    if (localGrid[y][x] === 1) {
                        ctx.fillStyle = '#444'; // Wall
                        ctx.fillRect(x*tileW, y*tileH, tileW, tileH);
                        // Bevel effect
                        ctx.fillStyle = '#555';
                        ctx.fillRect(x*tileW, y*tileH, tileW, 4);
                    } else {
                        // Floor dots
                        ctx.fillStyle = '#222';
                        ctx.beginPath();
                        ctx.arc(x*tileW + tileW/2, y*tileH + tileH/2, 2, 0, Math.PI*2);
                        ctx.fill();
                    }
                }
            }

            // Draw Players
            Object.values(playersMap).forEach(p => {
                ctx.fillStyle = p.color;
                // Simple square body
                ctx.fillRect(p.x*tileW + 2, p.y*tileH + 2, tileW - 4, tileH - 4);
                
                // Eyes (to show direction? just simple for now)
                ctx.fillStyle = 'white';
                ctx.fillRect(p.x*tileW + 5, p.y*tileH + 5, 4, 4);
                ctx.fillRect(p.x*tileW + 12, p.y*tileH + 5, 4, 4);
                
                // Name tag
                ctx.fillStyle = 'white';
                ctx.font = '8px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(p.name, p.x*tileW + tileW/2, p.y*tileH - 2);
            });
        }

        function loop() {
            draw();
            gameLoopId = requestAnimationFrame(loop);
        }

        // --- CONTROLS ---
        window.addEventListener('keydown', (e) => {
            if (views.game.classList.contains('hidden')) return;
            switch(e.key) {
                case 'ArrowUp': case 'w': movePlayer(0, -1); break;
                case 'ArrowDown': case 's': movePlayer(0, 1); break;
                case 'ArrowLeft': case 'a': movePlayer(-1, 0); break;
                case 'ArrowRight': case 'd': movePlayer(1, 0); break;
            }
        });

        // Touch Controls
        const btnUp = document.getElementById('btn-up');
        const btnDown = document.getElementById('btn-down');
        const btnLeft = document.getElementById('btn-left');
        const btnRight = document.getElementById('btn-right');
        
        const addTouch = (el, dx, dy) => {
            el.addEventListener('touchstart', (e) => { e.preventDefault(); movePlayer(dx, dy); });
            el.addEventListener('mousedown', (e) => { e.preventDefault(); movePlayer(dx, dy); });
        };
        addTouch(btnUp, 0, -1);
        addTouch(btnDown, 0, 1);
        addTouch(btnLeft, -1, 0);
        addTouch(btnRight, 1, 0);

        // General UI Bindings
        document.getElementById('btn-create-menu').onclick = createRoom;
        document.getElementById('btn-join-menu').onclick = () => switchView('join');
        document.getElementById('btn-back-join').onclick = () => switchView('menu');
        document.getElementById('btn-confirm-join').onclick = () => joinRoom(document.getElementById('input-room-code').value);
        document.getElementById('btn-start-game').onclick = triggerStart;
        document.getElementById('btn-leave-lobby').onclick = leaveRoom;
        document.getElementById('btn-exit-game').onclick = leaveRoom;

        document.getElementById('display-room-code').onclick = () => {
             const r = document.createRange(); r.selectNode(document.getElementById('display-room-code'));
             window.getSelection().removeAllRanges(); window.getSelection().addRange(r);
             document.execCommand('copy');
             alert("Copied!");
        };

        function leaveRoom() {
            if (roomUnsubscribe) roomUnsubscribe();
            if (gameLoopId) cancelAnimationFrame(gameLoopId);
            currentRoomId = null;
            localGrid = [];
            switchView('menu');
        }

        initAuth();

    </script>
</body>
</html>
